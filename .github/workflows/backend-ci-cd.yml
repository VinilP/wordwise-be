name: Backend CI/CD Pipeline

on:
  push:
    branches: [main, develop, staging]
    paths:
      - 'backend/**'
      - '.github/workflows/ci-cd.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - '.github/workflows/ci-cd.yml'

env:
  NODE_VERSION: '18'
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  IMAGE_NAME: book-review-platform-backend

jobs:
  # Linting and Code Quality
  lint:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Run ESLint
        run: npm run lint

      - name: Check Prettier formatting
        run: npm run format:check

      - name: TypeScript type check
        run: npx tsc --noEmit

  # Unit and Integration Tests
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: book_review_platform_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma client
        run: npx prisma generate

      - name: Run database migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/book_review_platform_test

      - name: Seed test database
        run: npx prisma db seed
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/book_review_platform_test

      - name: Run unit tests
        run: npm run test:unit
        env:
          NODE_ENV: test
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/book_review_platform_test
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: test-jwt-secret
          JWT_REFRESH_SECRET: test-refresh-secret
          OPENAI_API_KEY: test-openai-key

      - name: Run integration tests
        run: npm run test:integration
        env:
          NODE_ENV: test
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/book_review_platform_test
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: test-jwt-secret
          JWT_REFRESH_SECRET: test-refresh-secret
          OPENAI_API_KEY: test-openai-key

      - name: Generate coverage report
        run: npm run test:coverage
        env:
          NODE_ENV: test
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/book_review_platform_test
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: test-jwt-secret
          JWT_REFRESH_SECRET: test-refresh-secret
          OPENAI_API_KEY: test-openai-key

      - name: Check coverage threshold
        run: |
          COVERAGE=$(npm run test:coverage --silent | grep -o 'All files.*[0-9]\+\.[0-9]\+' | grep -o '[0-9]\+\.[0-9]\+' | tail -1)
          echo "Coverage: $COVERAGE%"
          if (( $(echo "$COVERAGE < 80" | bc -l) )); then
            echo "Coverage $COVERAGE% is below 80% threshold"
            exit 1
          fi
          echo "Coverage check passed: $COVERAGE%"

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage/lcov.info
          flags: backend
          name: backend-coverage
          fail_ci_if_error: true

  # Security Scanning
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run npm audit
        run: npm audit --audit-level=high

      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --file=backend/package.json

  # Build Docker Image
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [lint, test, security]
    if: github.event_name == 'push'
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.ECR_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json

  # Deploy to Development
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment:
      name: development
      url: https://${{ steps.deploy.outputs.app-url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Deploy infrastructure
        id: deploy
        run: |
          cd backend/terraform
          terraform init
          terraform plan -var-file="environments/dev.tfvars" -out=tfplan
          terraform apply tfplan
          
          # Get outputs
          ALB_DNS=$(terraform output -raw alb_dns_name)
          ECS_CLUSTER=$(terraform output -raw ecs_cluster_name)
          ECS_SERVICE=$(terraform output -raw ecs_service_name)
          
          echo "app-url=https://$ALB_DNS" >> $GITHUB_OUTPUT
          echo "ecs-cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
          echo "ecs-service=$ECS_SERVICE" >> $GITHUB_OUTPUT

      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --service ${{ steps.deploy.outputs.ecs-service }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --services ${{ steps.deploy.outputs.ecs-service }} \
            --region ${{ env.AWS_REGION }}

      - name: Run database migrations
        run: |
          # Get running task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --service-name ${{ steps.deploy.outputs.ecs-service }} \
            --desired-status RUNNING \
            --query 'taskArns[0]' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
            aws ecs execute-command \
              --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
              --task $TASK_ARN \
              --container book-review-platform-dev-app \
              --interactive \
              --command "npx prisma migrate deploy" \
              --region ${{ env.AWS_REGION }}
          fi

      - name: Health check
        run: |
          APP_URL="${{ steps.deploy.outputs.app-url }}"
          for i in {1..30}; do
            if curl -f -s "$APP_URL/health" > /dev/null; then
              echo "Health check passed: $APP_URL/health"
              exit 0
            fi
            echo "Health check attempt $i/30 failed, retrying in 10 seconds..."
            sleep 10
          done
          echo "Health check failed after 30 attempts"
          exit 1

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/staging' && github.event_name == 'push'
    environment:
      name: staging
      url: https://${{ steps.deploy.outputs.app-url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Deploy infrastructure
        id: deploy
        run: |
          cd backend/terraform
          terraform init
          terraform plan -var-file="environments/staging.tfvars" -out=tfplan
          terraform apply tfplan
          
          # Get outputs
          ALB_DNS=$(terraform output -raw alb_dns_name)
          ECS_CLUSTER=$(terraform output -raw ecs_cluster_name)
          ECS_SERVICE=$(terraform output -raw ecs_service_name)
          
          echo "app-url=https://$ALB_DNS" >> $GITHUB_OUTPUT
          echo "ecs-cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
          echo "ecs-service=$ECS_SERVICE" >> $GITHUB_OUTPUT

      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --service ${{ steps.deploy.outputs.ecs-service }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --services ${{ steps.deploy.outputs.ecs-service }} \
            --region ${{ env.AWS_REGION }}

      - name: Run database migrations
        run: |
          # Get running task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --service-name ${{ steps.deploy.outputs.ecs-service }} \
            --desired-status RUNNING \
            --query 'taskArns[0]' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
            aws ecs execute-command \
              --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
              --task $TASK_ARN \
              --container book-review-platform-staging-app \
              --interactive \
              --command "npx prisma migrate deploy" \
              --region ${{ env.AWS_REGION }}
          fi

      - name: Health check
        run: |
          APP_URL="${{ steps.deploy.outputs.app-url }}"
          for i in {1..30}; do
            if curl -f -s "$APP_URL/health" > /dev/null; then
              echo "Health check passed: $APP_URL/health"
              exit 0
            fi
            echo "Health check attempt $i/30 failed, retrying in 10 seconds..."
            sleep 10
          done
          echo "Health check failed after 30 attempts"
          exit 1

  # Deploy to Production
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: https://${{ steps.deploy.outputs.app-url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Create deployment backup
        id: backup
        run: |
          # Create RDS snapshot before deployment
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SNAPSHOT_ID="book-review-platform-prod-pre-deploy-$TIMESTAMP"
          
          aws rds create-db-snapshot \
            --db-instance-identifier book-review-platform-prod-db \
            --db-snapshot-identifier $SNAPSHOT_ID \
            --region ${{ env.AWS_REGION }}
          
          echo "snapshot-id=$SNAPSHOT_ID" >> $GITHUB_OUTPUT

      - name: Deploy infrastructure
        id: deploy
        run: |
          cd backend/terraform
          terraform init
          terraform plan -var-file="environments/prod.tfvars" -out=tfplan
          terraform apply tfplan
          
          # Get outputs
          ALB_DNS=$(terraform output -raw alb_dns_name)
          ECS_CLUSTER=$(terraform output -raw ecs_cluster_name)
          ECS_SERVICE=$(terraform output -raw ecs_service_name)
          
          echo "app-url=https://$ALB_DNS" >> $GITHUB_OUTPUT
          echo "ecs-cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
          echo "ecs-service=$ECS_SERVICE" >> $GITHUB_OUTPUT

      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --service ${{ steps.deploy.outputs.ecs-service }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --services ${{ steps.deploy.outputs.ecs-service }} \
            --region ${{ env.AWS_REGION }}

      - name: Run database migrations
        run: |
          # Get running task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --service-name ${{ steps.deploy.outputs.ecs-service }} \
            --desired-status RUNNING \
            --query 'taskArns[0]' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
            aws ecs execute-command \
              --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
              --task $TASK_ARN \
              --container book-review-platform-prod-app \
              --interactive \
              --command "npx prisma migrate deploy" \
              --region ${{ env.AWS_REGION }}
          fi

      - name: Health check
        id: health-check
        run: |
          APP_URL="${{ steps.deploy.outputs.app-url }}"
          for i in {1..30}; do
            if curl -f -s "$APP_URL/health" > /dev/null; then
              echo "Health check passed: $APP_URL/health"
              echo "success=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Health check attempt $i/30 failed, retrying in 10 seconds..."
            sleep 10
          done
          echo "Health check failed after 30 attempts"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1

      - name: Rollback on failure
        if: failure() && steps.health-check.outputs.success == 'false'
        run: |
          echo "Deployment failed, initiating rollback..."
          
          # Get previous task definition
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
            --services ${{ steps.deploy.outputs.ecs-service }} \
            --query 'services[0].taskDefinition' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          FAMILY=$(echo $CURRENT_TASK_DEF | cut -d':' -f1)
          CURRENT_REVISION=$(echo $CURRENT_TASK_DEF | cut -d':' -f2)
          PREVIOUS_REVISION=$((CURRENT_REVISION - 1))
          
          if [ $PREVIOUS_REVISION -gt 0 ]; then
            echo "Rolling back to revision $PREVIOUS_REVISION"
            aws ecs update-service \
              --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
              --service ${{ steps.deploy.outputs.ecs-service }} \
              --task-definition "$FAMILY:$PREVIOUS_REVISION" \
              --region ${{ env.AWS_REGION }}
            
            # Wait for rollback to complete
            aws ecs wait services-stable \
              --cluster ${{ steps.deploy.outputs.ecs-cluster }} \
              --services ${{ steps.deploy.outputs.ecs-service }} \
              --region ${{ env.AWS_REGION }}
          fi

      - name: Notify deployment status
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # Post-deployment smoke tests
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-prod]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: |
          cd backend
          npm ci

      - name: Run smoke tests
        run: |
          cd backend
          npm run test:smoke
        env:
          API_BASE_URL: ${{ needs.deploy-prod.outputs.app-url }}
          SMOKE_TEST_API_KEY: ${{ secrets.SMOKE_TEST_API_KEY }}